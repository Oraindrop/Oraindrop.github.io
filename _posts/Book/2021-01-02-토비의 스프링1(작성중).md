---
layout: post
title:  "도서 - 토비의 스프링 3.1 Vol 1 (작성중)"
categories: Book
author : choising
tags: java, book, spring
---

# 토비의 스프링 3.1 Vol 1 (~ 94p)

## 단어장

- 리팩토링
    - 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
- 디자인 패턴
    - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
- 템플릿 메소드 패턴
    - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
    - 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 하는 것
    - 서브클래스에서 *선택적으로* 오버라이드 할 수 있도록 만들어둔 메소드를 **훅(hook) 메소드** 라고 한다.
- 팩토리 메소드 패턴
    - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정
    - 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 **팩토리 메소드** 라고 한다.
- 객체지향 설계 원칙
    - SOLID
    - SRP(단일 책임 원칙), OCP(개방 폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존관계 역전 원칙)
- 개방 폐쇄 원칙 (OCP)
    - Open-Closed Principle
    - 객체지향 설계 원칙 중 하나
    - 클래스나 모듈은 확장에 열려있어야 하고, 변경에는 닫혀있어야 한다.
- 전략 패턴
    - 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고,
    - 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴


## 1장 오브젝트와 의존관계

### 1.2 DAO의 분리

- 관심사의 분리
    - Separation of Concerns
    - 관심사가 같은 것끼리 하나의 객체 or 친한 객체
    - 관심사가 다른 것은 가능한 한 서로 영향을 주지 않도록 분리

- UserDao add() 메소드의 관심사항

    ```
    public void add(User user) throws SQLException, ClassNotFoundException {
        Class.forName ("org.h2.Driver");
        Connection c = DriverManager.getConnection("jdbc:h2:mem:toby-spring", "sa", "");
        PreparedStatement ps = c.prepareStatement(
                "insert into user (id, name, password) values (?,?,?)");

        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }
    ```
    1. DB와 연결(커넥션)
        - 어떤 DB, 드라이버, 로그인 정보, 커넥션 생성방법
    2. DB에 요청할 SQL 문장을 담고 실행
        - 파라미터 바인딩, SQL 실행
    3. 리소스 해제

- 중복된 DB 연결코드 메소드 추출

    ```
    public void add(User user) throws SQLException, ClassNotFoundException {
        Connection c = getConnection();
        ...
        (생략)
    }

    private Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("org.h2.Driver");
        return DriverManager.getConnection("jdbc:h2:mem:toby-spring", "sa", "");
    }
    ```

- DB 커넥션 생성 방식의 추상화
    - Connection 을 생성하는 구체적인 코드를 상속받은 쪽에서.

    ```
    public abstract class UserDao {
        ...
        public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
    }

    public class CustomUserDao extends UserDao {

        @Override
        public Connection getConnection() throws ClassNotFoundException, SQLException {
            Class.forName("org.h2.Driver");
            return DriverManager.getConnection("jdbc:h2:mem:toby-spring", "sa", "");
        }
    }
    ```
    
    이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩이 가능한 메소드로 만든 뒤
    서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 **템플릿 메소드 패턴** 이라고 한다.

    또한 UserDao의 getConnection() 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드.
    UserDao의 서브클래스의 getConnection() 구현이 Connection 오브젝트를 어떻게 생성할 것인지 결정하는 방법.
    이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**

    - 단점
        - 상속을 사용했다.
        - 다중상속을 허용하지 않기에, UserDao가 다른 목적을 위해 상속을 사용하고 있었다면?
        - 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용함

### 1.3 DAO의 확장

- 클래스의 분리
    ```
    public class UserDao {

        private SimpleConnectionMaker simpleConnectionMaker;

        public UserDao() {
            simpleConnectionMaker = new SimpleConnectionMaker();
        }

        public void add(User user) throws SQLException, ClassNotFoundException {
            Connection c = simpleConnectionMaker.makeNewConnection();
            ...
        }
    }

    public class SimpleConnectionMaker {

        public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
            Class.forName("org.h2.Driver");
            return DriverManager.getConnection("jdbc:h2:mem:toby-spring", "sa", "");
        }
    }
    ```

    DB 커넥션 생성기능을 새로운 클래스로 분리, 독립 시킨다.

    - 단점
        - UserDao가 SimpleConnectionMaker 라는 특정 클래스에 종속되어 있다.
            - UserDao 코드 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.
        - DB 커넥션 제공 클래스의 메소드 명이 다를 수 있다.

- 인터페이스의 도입
    - 긴밀한 연결 사이 추상적인 느슨한 연결고리를 만들어준다.

    ```
    public interface ConnectionMaker {
        Connection makeConnection() throws ClassNotFoundException, SQLException;
    }

    public class SimpleConnectionMaker implements ConnectionMaker {

        @Override
        public Connection makeConnection() throws ClassNotFoundException, SQLException {
            Class.forName("org.h2.Driver");
            return DriverManager.getConnection("jdbc:h2:mem:toby-spring", "sa", "");
        }
    }

    public class UserDao {

        private ConnectionMaker connectionMaker;

        public UserDao(ConnectionMaker connectionMaker) {
            this.connectionMaker = connectionMaker;
        }

        ...
    }

    public class Application {

        public static void main(String[] args) throws SQLException, ClassNotFoundException {
            
            UserDao dao = new UserDao(new SimpleConnectionMaker());
            ...
        }
    }
    ```

    UserDao 클래스를 높은 응집도와 낮은 결합도 (high coherence and low coupling) 를 갖도록 리팩토링
    **높은 응집도** 란, 하나의 책임 또는 관심사에만 집중되어있는 형태
    **낮은 결합도** 란, 다른 모듈과 느슨하게 연결된 형태

#### 전략 패턴

- MainClass - UserDao - ConnectionMaker 구조는 전략(Strategy) 패턴에 해당한다.
- UserDao 는 전략 패턴의 **컨텍스트**
    - 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중 변경 가능한 DB 연결 방식이라는 알고리즘을 ConnectionMaker 라는 인터페이스로 정의하고
    - 이를 구현한 클래스(즉 전략)를 변경하며 사용할 수 있게 분리했다.
- 컨텍스트(UserDao) 를 사용하는 클라이언트(MainClass) 는 컨텍스트가 사용할 전략(ConnectionMaker를 구현한 클래스)을 컨텍스트의 생성자 등을 통해 선택, 제공


### 1.4 제어의 역전(IoC)

- 오브젝트 팩토리
    ```
    public class DaoFactory {

        public UserDao userDao() {
            return new UserDao(new SimpleConnectionMaker());
        }
    }

    public class Application {

        public static void main(String[] args) throws SQLException, ClassNotFoundException {
            
            UserDao dao = new DaoFactory().userDao();
            ...
        }
    }
    ```

    책임의 분리, 어떤 ConnectionMaker 구현 클래스를 사용할 지 결정하는 기능을 팩토리 클래스에게 완벽히 위임한다.
    오브젝트를 생허나는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리
    어떻게 만들지와 어떻게 사용할지는 분명 다른 관심이다.

#### 1.4.3 제어권 이전을 통한 제어관계 역전

- 일반적인 프로그램 흐름 상
    - main() 메소드와 같은 프로그램 시작부에서 다음 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들어진 오브젝트에 있는 메소드를 호출하고, 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다.
    - 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.
    - *모든 종류의 작업을 사용하는 쪽에서 제어하는 구조*

- 제어의 역전이란 이러한 제어 흐름의 개념을 거꾸로 뒤집는 것.
    - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 생성하지도 않는다. 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
    - *제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.*

- 제어의 역전의 개념을 쉽게 보면
    - UserDao 개선 작업 시 서브클래스를 만들었을 때.
    - 서브클래스가 getConnection() 을 구현하지만, 메소드가 언제 어떻게 사용될지는 자신은 모른다.
    - 슈퍼클래스의 템플릿 메소드에서 필요시 호출해서 사용하는 것.
    - 이처럼 제어권을 상위에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는 개념

- 라이브러리와 프레임워크의 차이
    - 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.
    - 동작 중 필요한 기능이 있을 때 능동적으로 라이브러리 사용.
    - 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
    - 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만든 방식.
    - 즉 필자는 분명한 제어의 역전개념이 적용되어있어야 프레임워크라고 말하고 있다.
























