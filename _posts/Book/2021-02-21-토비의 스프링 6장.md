---
layout: post
title:  "도서 - 토비의 스프링 3.1 Vol 1, 6장 (작성중)"
categories: Book
author : choising
tags: java, book, spring
---

# 토비의 스프링 3.1 Vol 1 (401p ~ 464p)

## 6장 AOP

### 6.1 트랜잭션 코드의 분리

#### 6.1.1 메소드 분리

- UserService 의 트랜잭션 경계설정 코드와 비즈니스 로직 코드가 복잡하게 얽혀 있는 듯 보이지만, 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.

- 비즈니스 로직 코드를 사이에 두고 트랜잭션의 시작과 종료를 담당

- 트랜잭션 경계설정 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없이 독립적이다.

- 비즈니스 로직만 추출한 예

```
public void upgradeLevels() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

    try {
        upgradeLevelsInternal();    // here!!
        transactionManager.commit(status);
    } catch (RuntimeException e) {
        transactionManager.rollback(status);
        throw e;
    }
}

private void upgradeLevelsInternal() {
    List<User> users = userDao.getAll();

    for (User user : users) {
        if (userLevelUpgradePolicy.canUpgradeLevel(user)) {
            userLevelUpgradePolicy.upgradeLevel(user);
        }
    }
}
```

#### 6.1.2 DI를 이용한 클래스 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService` 클래스에 있다.

- 여태 DI를 적용했던 이유는 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서
    - 테스트에 따라 테스트 구현클래스 등
    - 하지만 꼭 이것 때문에 DI를 쓰는건 아님

- UserService 의 책임을 나눈 구현 클래스를 두 개 만든다.
    - ![UserServiceTx](https://github.com/Oraindrop/oraindrop.github.io/blob/master/assets/_img/UserServiceTx.png?raw=true)

- UserService interface

```
public interface UserService {
    void add(User user);
    void upgradeLevels();
}
```

- 비즈니스 로직만 들고 있는 UserServiceImpl

```
public class UserServiceImpl implements UserService {

    ...

    @Override
    public void upgradeLevels() {
        List<User> users = userDao.getAll();

        for (User user : users) {
            if (userLevelUpgradePolicy.canUpgradeLevel(user)) {
                userLevelUpgradePolicy.upgradeLevel(user);
            }
        }
    }

    @Override
    public void add(User user) {
        if (user.getLevel() == null) {
            user.setLevel(Level.BASIC);
        }

        userDao.add(user);
    }

    ...
}
```

- 트랜잭션 경계설정 + 작업 위임하는 UserServiceTx

```
public class UserServiceTx implements UserService {

    private UserService userService;

    ...

    @Override
    public void upgradeLevels() {
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels();
            transactionManager.commit(status);
        } catch (RuntimeException e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    ...
}
```

- 장점
    - 비즈니스 로직을 담당하고 있는 UserServiceImpl 의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

### 6.2. 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트 하는 것.
    - 좋은 이유는, 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문
    - 의도나 내용이 분명, 만들기도 쉬워짐

- asis upgradeLevels() 테스트
    - ![upgradeLevelsTest](https://github.com/Oraindrop/oraindrop.github.io/blob/master/assets/_img/upgradeLevelsTest.PNG?raw=true)
    1. 테스트용 정보를 DB에 넣는다.
    2. 메일 발송 여부를 확인하기 위해 MailSender Mock Object 를 DI
    3. 실제 테스트 대상인 userService 메소드 실행
    4. DB에서 데이터를 가져와 결과 확인
    5. Mock 오브젝트에서 데이터를 가져와 UserService 에 의한 메일 발송이 있었는지 확인

- mock userDao

```
static class MockUserDao implements UserDao {
    private List<User> users;

    private List<User> updated = new ArrayList<>();

    private MockUserDao(List<User> users) {
        this.users = users;
    }

    public List<User> getUpdated() {
        return this.updated;
    }

    public List<User> getAll() {
        return this.users;
    }

    public void update(User user) {
        updated.add(user);
    }

    public void add(User user) { throw new UnsupportedOperationException(); };
    public void deleteAll() { throw new UnsupportedOperationException(); };
    public User get(String id) { throw new UnsupportedOperationException(); };
    public int getCount() { throw new UnsupportedOperationException(); };
}
```
- upgradeLevels test use mock userDao  

```
public void upgradeLevels() {
    UserServiceImpl userServiceImpl = new UserServiceImpl(new MockUserDao(this.users));

    ...

    userServiceImpl.upgradeLevels();

    List<User> updated = mockUserDao.getUpdated();
    assertEquals(updated.size(), 2);
    assertEquals(updated.get(0).getLevel(), Level.SILVER);
    assertEquals(updated.get(1).getLevel(), Level.GOLD);

    ...
}
```

- 테스트 대역 오브젝트를 이용해 완전히 고립된 테스트를 만듬
    - 스프링 컨테이너에서 빈을 가져올 필요가 없다.
    - 테스트 수행 성능이 향상된다.
        - 테스트가 빨리 돌아가면 부담 없이 자주 테스트를 돌려볼 수 있다.
    - 의존 대상 영향을 고려하지 않아도 된다.

- 고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르나, 그 보상은 충분히 기대할 만하다.

#### Mockito 프레임워크

- mock 생성

```
UserDao mockUserDao = mock(UserDao.class);
```

- 메소드 리턴값 정의

```
when(mockUserDao.getAll()).thenReturn(this.users);
```

- 메소드 호출 횟수 확인

```
verify(mockUserDao, times(2)).update(any(User.class));
```

- 메소드 파라미터 캡쳐

```
ArgumentCaptor<SimpleMailMessage> mailMessageArg = ArgumentCaptor.forClass(SimpleMailMessage.class);
verify(mockMailSender, times(2)).send(mailMessageArg.capture())
List<SimpleMailMessage> mailMessages = mailMessageArg.getAllValues();

// assert
```

#### 6.3 다이내믹 프록시와 팩토리 빈

- 트랜잭션이라는 부가기능을 UserServiceTx, 핵심기능을 UserServiceImpl 로 분리했다.
- 중요한 특징이 있다.
    - 부가기능 외에 나머지 모든 기능은 원래 핵심 기능을 가진 클래스로 위임.
    - 즉, 부가기능이 핵심기능을 사용하는 구조가 된다.
    - 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능 적용 기회가 없다.
    - 그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 사용하도록 만들어야 한다.

- 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것 처럼 위장해서 클라이언트의 요청을 받아주는 것을 `프록시(proxy)` 라 부른다.
    - 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 `타깃(target)`, `실체(real object)` 라 부른다.

- 프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과, 프록시가 타깃을 제어할 수 있는 위치에 있다는 것.
    
- 프록시의 사용 목적
    - 클라이언트가 타깃에 접근하는 방법을 제어
    - 타깃에 부가적인 기능을 부여하기 위해

##### 데코레이터 패턴

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
    - 다이내믹하게 <- 의 의미는 컴파일 시점(코드 상) 에는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻

- 실제 내용물은 동일하지만 부가적인 효과를 부여

- 프록시가 꼭 한개로 제한되지는 않는다.

- 예를들어 소스코드를 출력하는 기능을 가진 핵심 기능
    - 데코레이터 개념을 부여, 타깃과 같은 인터페이스를 구현, 런타임 시 이를 적절한 순서로 조합해서 사용
        - 소스코드에 라인넘버를 붙여주는 데코레이터 -> 신텍스 하이리팅 하는 데코레이터 -> 페이징 데코레이터 -> 핵심 기능 (타깃)

- 데코레이터의 다음 위임 대상은 인터페이스로 주입 받아야 한다.
    - 다음 대상이 최종 타깃인지, 다음단계 데코레이터 프록시인지 알지 못하기 때문

- 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

##### 프록시 패턴

- 프록시라는 용어와 디자인 패턴의 프록시 패턴은 다르다.

- 프록시 패턴은 타깃에 대한 접근방법을 제어하려는 목적을 가진 경우를 가리킨다.
    - 타깃의 기능을 확장하거나 추가하지 않는다.
    - 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.

- 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않으나 오브젝트의 레퍼런스가 미리 필요한 경우, 실제 타깃 오브젝트 대신 프록시를 넘겨주는 것.
    - 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식

- 레퍼런스를 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면 생성을 최대한 늦춤으로써 얻는 장점이 많다.

- 원격 오브젝트를 이용하는 경우에도 프록시를 사용하면 편리하다.
    - 다른 서버에 존재하는 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼

- 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴 사용
    - 특정 레이어에서 읽기전용으로 동작하는 경우

- 이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.

- 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 부가 기능 또는 접근 제어를 담당하는 오브젝트는 모두 프록시

#### 6.3.2 다이내믹 프록시

- 프록시는 다음 두 가지 기능으로 구성된다.
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임.
    - 지정된 요청에 대해서는 부가기능 수행.

- 프록시가 만들기 번거로운 이유
    1. 타깃의 인터페이스를 구현하고 위임하는 코드 작성이 번거롭다.
        - 부가기능이 필요없는 메소드도 구현, 위임 필요
    2. 부가기능 코드의 중복 가능성

- 목 오브젝트와 비슷하게 프록시를 손쉽게 만드는 것을 도와주는 API 가 존재한다
    - JDK 의 **다이내믹 프록시**

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것.
    - 학습 테스트

    ```
    @Test
    public void invokeMethod() throws Exception {
        String name = "Spring";

        assertEquals(name.length(), 6);

        Method lengthMethod = String.class.getMethod("length");
        assertEquals((Integer)lengthMethod.invoke(name), 6);

        assertEquals(name.charAt(0), 'S');

        Method charAtMethod = String.class.getMethod("charAt", int.class);
        assertEquals((Character)charAtMethod.invoke(name, 0), 'S');
    }
    ```
    
    invoke() 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아 메소드를 호출한 뒤 그 결과를 Object 타입으로 돌려준다.

- 다이내믹 프록시 학습테스트 예제

    - Hello Interface
    
    ```
    public interface Hello {

        String sayHello(String name);

        String sayHi(String name);

        String sayThankYou(String name);
    }
    ```

    - 타깃 클래스

    ```
    public class HelloTarget implements Hello {
        @Override
        public String sayHello(String name) {
            return "Hello " + name;
        }

        @Override
        public String sayHi(String name) {
            return "Hi " + name;
        }

        @Override
        public String sayThankYou(String name) {
            return "Thank You " + name;
        }
    }
    ```

    - 프록시

    ```
    public class UppercaseHandler implements InvocationHandler {

        Object target;

        public UppercaseHandler(Object target) {
            this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object ret = method.invoke(target, args);
            if (ret instanceof  String && method.getName().startsWith("say")) {
                return ((String)ret).toUpperCase();
            } else {
                return ret;
            }
        }
    }
    ```

    - 클라이언트 (학습테스트)

    ```
    @Test
    public void simpleProxy() {
        Hello hello = new HelloTarget();
        assertEquals(hello.sayHello("Toby"), "Hello Toby");
        assertEquals(hello.sayHi("Toby"), "Hi Toby");
        assertEquals(hello.sayThankYou("Toby"), "Thank You Toby");

        Hello proxiedHello = (Hello) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] {
                Hello.class
        }, new UppercaseHandler(new HelloTarget()));

        assertEquals(proxiedHello.sayHello("Toby"), "HELLO TOBY");
        assertEquals(proxiedHello.sayHi("Toby"), "HI TOBY");
        assertEquals(proxiedHello.sayThankYou("Toby"), "THANK YOU TOBY");
    }
    ```

#### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능

- UserServiceTx 를 다이내믹 프록시 방식으로 변경해보자.

```
@Test
@DirtiesContext
public void upgradeAllOrNothing() {
    UserService target = new UserServiceImpl(userDao, new UserLevelUpgradePolicyTest(userDao, users.get(3).getId()));
    TransactionHandler txHandler = new TransactionHandler(target, new DataSourceTransactionManager(dataSource), "upgradeLevels");
    UserService txUserService = (UserService) Proxy.newProxyInstance(getClass().getClassLoader()
            , new Class[] {UserService.class}, txHandler);

    userDao.deleteAll();

    for (User user : users) {
        userDao.add(user);
    }
    Assertions.assertThrows(TestUserServiceException.class, txUserService::upgradeLevels);

    checkLevelUpgraded(users.get(1), false);
}
```

#### 6.3.4 다이내믹 프록시를 위한 팩토리 빈

- 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링 빈에 정의할 방법이 없다.

- 다이내믹 프록시는 Proxy 클래스의 newProxyInstance() 라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

- 팩토리 빈
    - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
    - 팩토리 빈을 만드는 여러 방법 중 스프링의 FactoryBean 인터페이스를 구현할 수도 있다.
    - FactoryBaen 인터페이스
        ```
        public interface FactoryBean<T> {

            String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

            @Nullable
            T getObject() throws Exception; // 빈 오브젝트 생성, return

            @Nullable
            Class<?> getObjectType();   //  생성되는 오브젝트 타입

            default boolean isSingleton() {  // getObject()가 항상 같은 오브젝트를 리턴하는가
                return true;
            }
        }
        ```
    
- 학습 테스트
    - private 생성자 클래스

    ```
    public class Message {

        private String text;

        private Message(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }

        public static Message newMessage(String text) {
            return new Message(text);
        }
    }
    ```

    - 사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록하면 리플렉션을 사용해 오브젝트를 만들 수 있다.
    - 하지만 private 로 선언되었다는 것은 스테틱 메소드를 통해 오브젝트가 만들어져야 하는 중요한 이유가 있을 수 있으므로 이를 무시하고 강제로 오브젝트 생성하는 것은 위험하다.
    - Message 클래스의 오브젝트를 생성해주는 팩토리 빈 클래스

    ```
    public class MessageFactoryBean implements FactoryBean<Message> {

        private String text;

        public MessageFactoryBean(String text) {
            this.text = text;
        }

        @Override
        public Message getObject() throws Exception {
            return Message.newMessage(this.text);
        }

        @Override
        public Class<?> getObjectType() {
            return Message.class;
        }

        @Override
        public boolean isSingleton() {
            return false;
        }
    }
    ```

- 다이내믹 프록시를 만들어주는 팩토리 빈

```
public class TxProxyFactoryBean implements FactoryBean<Object> {

    private Object target;
    private PlatformTransactionManager transactionManager;
    private String pattern;
    Class<?> serviceInterface;

    @Override
    public boolean isSingleton() {
        return false;
    }

    public TxProxyFactoryBean(Object target, PlatformTransactionManager transactionManager, String pattern, Class<?> serviceInterface) {
        this.target = target;
        this.transactionManager = transactionManager;
        this.pattern = pattern;
        this.serviceInterface = serviceInterface;
    }

    @Override
    public Object getObject() throws Exception {
        TransactionHandler txHandler = new TransactionHandler(this.target, this.transactionManager, this.pattern);
        return Proxy.newProxyInstance(
                getClass().getClassLoader(), new Class[] { serviceInterface }, txHandler
        );
    }

    @Override
    public Class<?> getObjectType() {
        return serviceInterface;
    }
}
```

- 예외 발생 시 트랜잭션 롤백됨을 확인하려면 테스트 코드에서 FactoryBean 을 DI 받아 TestUserService 오브젝트를 타깃 오브젝트로 Object를 생성하면 된다.

#### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

- 장점
    - 한 번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있다.
        - TransactionHandler 를 이용하는 다이내믹 프록시를 생성해주는 TxProxytFactoryBean 은 코드의 수정 없이도 다양한 클래스에 적용할 수 있다. 타깃 오브젝트만 맞도록 변경하여 빈으로 등록해주면 된다.
    - 다이내믹 프록시를 사용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
    - 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있으니 부가기능 코드 중복 문제도 해결된다.
    - DI 덕분이다. DI 짱.

- 한계
    - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공할 수 없다.
        - 타깃 오브젝트는 하나.
    - 하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때 문제다.
        - 프록시 팩토리 빈 설정(xml, 코드 등)이 부가기능의 개수만큼 늘어난다.
        - 설정파일이 복잡해진다.
        - TransactionHandler 가 프록시 팩토리 빈 개수만큼 만들어진다.

### 6.4 스프링의 프록시 팩토리 빈

- 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공한다.
- 스프링의 ProxyFactoryBean 은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다. 기존에 만들었던 TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만 담당하고, 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.
    - 부가기능은 MethodInterceptor 인터페이스를 구현
        - InvocationHandler 와 비슷하지만, MethodInterceptor 의 invoke() 메소드는 ProxyFactoryBean 으로부터 타깃 오브젝트에 대한 정보까지 함께 제공받는다.
            - 덕분에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
            






