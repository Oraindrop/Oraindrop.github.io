---
layout: post
title:  "도서 - 토비의 스프링 3.1 Vol 1, 6장 (작성중)"
categories: Book
author : choising
tags: java, book, spring
---

# 토비의 스프링 3.1 Vol 1 (401p ~ p)

## 6장 AOP

### 6.1 트랜잭션 코드의 분리

#### 6.1.1 메소드 분리

- UserService 의 트랜잭션 경계설정 코드와 비즈니스 로직 코드가 복잡하게 얽혀 있는 듯 보이지만, 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.

- 비즈니스 로직 코드를 사이에 두고 트랜잭션의 시작과 종료를 담당

- 트랜잭션 경계설정 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없이 독립적이다.

- 비즈니스 로직만 추출한 예

```
public void upgradeLevels() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

    try {
        upgradeLevelsInternal();    // here!!
        transactionManager.commit(status);
    } catch (RuntimeException e) {
        transactionManager.rollback(status);
        throw e;
    }
}

private void upgradeLevelsInternal() {
    List<User> users = userDao.getAll();

    for (User user : users) {
        if (userLevelUpgradePolicy.canUpgradeLevel(user)) {
            userLevelUpgradePolicy.upgradeLevel(user);
        }
    }
}
```

#### 6.1.2 DI를 이용한 클래스 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService` 클래스에 있다.

- 여태 DI를 적용했던 이유는 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서
    - 테스트에 따라 테스트 구현클래스 등
    - 하지만 꼭 이것 때문에 DI를 쓰는건 아님

- UserService 의 책임을 나눈 구현 클래스를 두 개 만든다.
    - ![UserServiceTx](https://github.com/Oraindrop/oraindrop.github.io/blob/master/assets/_img/UserServiceTx.png?raw=true)

- UserService interface

```
public interface UserService {
    void add(User user);
    void upgradeLevels();
}
```

- 비즈니스 로직만 들고 있는 UserServiceImpl

```
public class UserServiceImpl implements UserService {

    ...

    @Override
    public void upgradeLevels() {
        List<User> users = userDao.getAll();

        for (User user : users) {
            if (userLevelUpgradePolicy.canUpgradeLevel(user)) {
                userLevelUpgradePolicy.upgradeLevel(user);
            }
        }
    }

    @Override
    public void add(User user) {
        if (user.getLevel() == null) {
            user.setLevel(Level.BASIC);
        }

        userDao.add(user);
    }

    ...
}
```

- 트랜잭션 경계설정 + 작업 위임하는 UserServiceTx

```
public class UserServiceTx implements UserService {

    private UserService userService;

    ...

    @Override
    public void upgradeLevels() {
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels();
            transactionManager.commit(status);
        } catch (RuntimeException e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    ...
}
```

- 장점
    - 비즈니스 로직을 담당하고 있는 UserServiceImpl 의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

### 6.2. 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트 하는 것.
    - 좋은 이유는, 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문
    - 의도나 내용이 분명, 만들기도 쉬워짐

- asis upgradeLevels() 테스트
    - ![upgradeLevelsTest](https://github.com/Oraindrop/oraindrop.github.io/blob/master/assets/_img/upgradeLevelsTest.PNG?raw=true)
    1. 테스트용 정보를 DB에 넣는다.
    2. 메일 발송 여부를 확인하기 위해 MailSender Mock Object 를 DI
    3. 실제 테스트 대상인 userService 메소드 실행
    4. DB에서 데이터를 가져와 결과 확인
    5. Mock 오브젝트에서 데이터를 가져와 UserService 에 의한 메일 발송이 있었는지 확인

- mock userDao

```
static class MockUserDao implements UserDao {
    private List<User> users;

    private List<User> updated = new ArrayList<>();

    private MockUserDao(List<User> users) {
        this.users = users;
    }

    public List<User> getUpdated() {
        return this.updated;
    }

    public List<User> getAll() {
        return this.users;
    }

    public void update(User user) {
        updated.add(user);
    }

    public void add(User user) { throw new UnsupportedOperationException(); };
    public void deleteAll() { throw new UnsupportedOperationException(); };
    public User get(String id) { throw new UnsupportedOperationException(); };
    public int getCount() { throw new UnsupportedOperationException(); };
}
```
- upgradeLevels test use mock userDao  

```
public void upgradeLevels() {
    UserServiceImpl userServiceImpl = new UserServiceImpl(new MockUserDao(this.users));

    ...

    userServiceImpl.upgradeLevels();

    List<User> updated = mockUserDao.getUpdated();
    assertEquals(updated.size(), 2);
    assertEquals(updated.get(0).getLevel(), Level.SILVER);
    assertEquals(updated.get(1).getLevel(), Level.GOLD);

    ...
}
```

- 테스트 대역 오브젝트를 이용해 완전히 고립된 테스트를 만듬
    - 스프링 컨테이너에서 빈을 가져올 필요가 없다.
    - 테스트 수행 성능이 향상된다.
        - 테스트가 빨리 돌아가면 부담 없이 자주 테스트를 돌려볼 수 있다.
    - 의존 대상 영향을 고려하지 않아도 된다.

- 고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르나, 그 보상은 충분히 기대할 만하다.

#### Mockito 프레임워크

- mock 생성

```
UserDao mockUserDao = mock(UserDao.class);
```

- 메소드 리턴값 정의

```
when(mockUserDao.getAll()).thenReturn(this.users);
```

- 메소드 호출 횟수 확인

```
verify(mockUserDao, times(2)).update(any(User.class));
```

- 메소드 파라미터 캡쳐

```
ArgumentCaptor<SimpleMailMessage> mailMessageArg = ArgumentCaptor.forClass(SimpleMailMessage.class);
verify(mockMailSender, times(2)).send(mailMessageArg.capture())
List<SimpleMailMessage> mailMessages = mailMessageArg.getAllValues();

// assert
```

#### 6.3 다이내믹 프록시와 팩토리 빈

- 트랜잭션이라는 부가기능을 UserServiceTx, 핵심기능을 UserServiceImpl 로 분리했다.
- 중요한 특징이 있다.
    - 부가기능 외에 나머지 모든 기능은 원래 핵심 기능을 가진 클래스로 위임.
    - 즉, 부가기능이 핵심기능을 사용하는 구조가 된다.
    - 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능 적용 기회가 없다.
    - 그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 사용하도록 만들어야 한다.

- 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것 처럼 위장해서 클라이언트의 요청을 받아주는 것을 `프록시(proxy)` 라 부른다.
    - 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 `타깃(target)`, `실체(real object)` 라 부른다.

- 프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과, 프록시가 타깃을 제어할 수 있는 위치에 있다는 것.
    
- 프록시의 사용 목적
    - 클라이언트가 타깃에 접근하는 방법을 제어
    - 타깃에 부가적인 기능을 부여하기 위해

##### 데코레이터 패턴

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
    - 다이내믹하게 <- 의 의미는 컴파일 시점(코드 상) 에는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻

- 실제 내용물은 동일하지만 부가적인 효과를 부여

- 프록시가 꼭 한개로 제한되지는 않는다.

- 예를들어 소스코드를 출력하는 기능을 가진 핵심 기능
    - 데코레이터 개념을 부여, 타깃과 같은 인터페이스를 구현, 런타임 시 이를 적절한 순서로 조합해서 사용
        - 소스코드에 라인넘버를 붙여주는 데코레이터 -> 신텍스 하이리팅 하는 데코레이터 -> 페이징 데코레이터 -> 핵심 기능 (타깃)

- 데코레이터의 다음 위임 대상은 인터페이스로 주입 받아야 한다.
    - 다음 대상이 최종 타깃인지, 다음단계 데코레이터 프록시인지 알지 못하기 때문

- 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

##### 프록시 패턴

- 프록시라는 용어와 디자인 패턴의 프록시 패턴은 다르다.

- 프록시 패턴은 타깃에 대한 접근방법을 제어하려는 목적을 가진 경우를 가리킨다.
    - 타깃의 기능을 확장하거나 추가하지 않는다.
    - 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.

- 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않으나 오브젝트의 레퍼런스가 미리 필요한 경우, 실제 타깃 오브젝트 대신 프록시를 넘겨주는 것.
    - 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식

- 레퍼런스를 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면 생성을 최대한 늦춤으로써 얻는 장점이 많다.

- 원격 오브젝트를 이용하는 경우에도 프록시를 사용하면 편리하다.
    - 다른 서버에 존재하는 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼

- 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴 사용
    - 특정 레이어에서 읽기전용으로 동작하는 경우

- 이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.

- 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 부가 기능 또는 접근 제어를 담당하는 오브젝트는 모두 프록시

#### 6.3.2 다이내믹 프록시

- 프록시는 다음 두 가지 기능으로 구성된다.
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임.
    - 지정된 요청에 대해서는 부가기능 수행.

- 프록시가 만들기 번거로운 이유
    1. 타깃의 인터페이스를 구현하고 위임하는 코드 작성이 번거롭다.
        - 부가기능이 필요없는 메소드도 구현, 위임 필요
    2. 부가기능 코드의 중복 가능성

- 목 오브젝트와 비슷하게 프록시를 손쉽게 만드는 것을 도와주는 API 가 존재한다
    - JDK 의 **다이내믹 프록시**

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것.
    - 학습 테스트

    ```
    @Test
    public void invokeMethod() throws Exception {
        String name = "Spring";

        assertEquals(name.length(), 6);

        Method lengthMethod = String.class.getMethod("length");
        assertEquals((Integer)lengthMethod.invoke(name), 6);

        assertEquals(name.charAt(0), 'S');

        Method charAtMethod = String.class.getMethod("charAt", int.class);
        assertEquals((Character)charAtMethod.invoke(name, 0), 'S');
    }
    ```
    
    invoke() 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아 메소드를 호출한 뒤 그 결과를 Object 타입으로 돌려준다.

- 다이내믹 프록시 학습테스트 예제

    - Hello Interface
    
    ```
    public interface Hello {

        String sayHello(String name);

        String sayHi(String name);

        String sayThankYou(String name);
    }
    ```

    - 타깃 클래스

    ```
    public class HelloTarget implements Hello {
        @Override
        public String sayHello(String name) {
            return "Hello " + name;
        }

        @Override
        public String sayHi(String name) {
            return "Hi " + name;
        }

        @Override
        public String sayThankYou(String name) {
            return "Thank You " + name;
        }
    }
    ```

    - 프록시

    ```
    public class UppercaseHandler implements InvocationHandler {

        Object target;

        public UppercaseHandler(Object target) {
            this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object ret = method.invoke(target, args);
            if (ret instanceof  String && method.getName().startsWith("say")) {
                return ((String)ret).toUpperCase();
            } else {
                return ret;
            }
        }
    }
    ```

    - 클라이언트 (학습테스트)

    ```
    @Test
    public void simpleProxy() {
        Hello hello = new HelloTarget();
        assertEquals(hello.sayHello("Toby"), "Hello Toby");
        assertEquals(hello.sayHi("Toby"), "Hi Toby");
        assertEquals(hello.sayThankYou("Toby"), "Thank You Toby");

        Hello proxiedHello = (Hello) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] {
                Hello.class
        }, new UppercaseHandler(new HelloTarget()));

        assertEquals(proxiedHello.sayHello("Toby"), "HELLO TOBY");
        assertEquals(proxiedHello.sayHi("Toby"), "HI TOBY");
        assertEquals(proxiedHello.sayThankYou("Toby"), "THANK YOU TOBY");
    }
    ```

#### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능

- UserServiceTx 를 다이내믹 프록시 방식으로 변경해보자.









