---
layout: post
title:  "TIL(20190414)"
categories: TIL
author : choising
tags: til
---

# 20190414

## SQL 레벨업 ( ~ 40P)

### 1강 DBMS 아키텍처 개요

1. 쿼리 평가 엔진

- 사용자로부터 입력받은 SQL 구문을 분석, 어떤 순서로 기억장치의 데이터에 접근할지 결정
    - 이 때, 결정되는 계획을 `실행 계획` 또는 `실행 플랜` 이라 부른다
    - 이런 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 `접근 메서드(access method)`

- 한 마디로 쿼리 평가 엔진은 계획을 세우고 실행하는 DBMS의 핵심기능을 담당하는 모듈


4. 트랜잭션 매니저와 락 매니저

- 상용 시스템에서 복수의 사람이 동시에 DB에 접근해 사용한다
    - 이 때 각각 처리는 `트랜잭션` 이라는 단위로 관리된다
    - 트랜잭선의 정합성을 유지하면서 실행 시키고, 필요한 경우 데이터에 락을 걸어 다른 요청을 대기시키는 역할을 한다


### 2강 DBMS와 버퍼

- `기억 비용` 이라는 것은
    - 데이터를 저장하는데 소모되는 비용

- DBMS가 사용하는 대표적인 기억장치
    - 하드디스크
    - 메모리

- 버퍼(캐시)를 활용한 속도 향상
    - SQL 구문의 실행 속도를 빠르게 만들기 위해 DBMS 는 일부라도 데이터를 메모리에 올린다
    - 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도 더 빠르다

- DBMS가 사용하는 메모리는 두 가지 종류
    - 데이터 캐시
        - 데이터 일부를 메모리에 유지
    - 로그 버퍼
        - DBMS는 갱신 SQL을 받았을 때, 로그 버퍼 위에 변경 정보를 보내고 이후에 디스크를 변경한다

- 메모리의 성질이 초래하는 트레이드오프
    - 휘발성
    - 로그 파일에 전달된 갱신정보가 DBMS가 장애로 다운될 때 사라져 버린다면 문제가 발생
        - DBMS가 갱신을 비동기로 하게 되면 언제든 발생할 수 있는 문제
        - 때문에, DBMS는 `커밋`이란 갱신처리를 확정(디스크에 동기 접근)
            - DBMS는 커밋 시점에 반드시 갱신 정보를 로그파일에 씀으로써 장애가 발생해도 정합성을 유지
        - 디스크에 동기 처리 한다면 데이터의 정합성은 높아지지만 성능은 낮아진다

- 대부분의 DBMS에서 공통으로 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다.
    - 그 이유는 기본적으로 `검색을 메인`으로 처리한다고 가정하기 때문
    - 당연히 갱신이 많다면 로그 버퍼의 크기를 늘려주는 튜닝이 필요함

- **검색**과 **갱신** 중에서 중요한 것을 정해야한다
    - 메모리라는 비싼 희소 자원으로 모든 것을 커버하기에는 부족하므로 우선순위가 필요

- 추가적인 메모리 영역 `워킹 메모리`
    - 정렬 또는 해시 관련 처리에 사용되는 작업용 영역
    - 정렬 : ORDER BY, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행
    - 해시 : 테이블의 결합(해시 결합)
    - ex) 오라클의 `PGA`, PostgreSQL의 `워크 버퍼`, MySQL의 `정렬 버퍼`
    - 만약, 이 영역이 다루려는 데이터 양보다 작아 부족해지는 경우가 생기면 대부분의 경우 저장소를 사용한다 (성능적으로 중요하다)
        - 이 때 사용하는 영역의 이름은 오라클 *TEMP Tablespace*, MSSQL *TEMPDB*, PostgreSQL *pgsql_tmp*
        - 저장소 위에 있으므로 당연히 접근 속도가 느리다



    


