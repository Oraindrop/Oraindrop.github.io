---
layout: post
title:  "TIL(20181123)"
categories: TIL
author : choising
tags: til
---

# 20181123

## JAVA Web Back-end

- http 프로토콜은 기본적으로 stateless(무상태)
    - 단점을 극복하고자 cookie, session 개념을 도입.

- LOB
    - CLOB : 문자열을 담는 큰 데이터 타입
    - BLOB : 이미지, 동영상 등을 담는 큰 데이터 타입

- TDD
    - UI / DB 등과 의존성이 맺어진 코드는 단위테스트가 힘들다.
    - Web Programming 에서는 모든 부분을 TDD로 진행할 수 없다.
        - domain(entity) 로직만 TDD로 개발하는 것을 권장.

- uni-direction, bi-direction
    - 불필요 하다면 uni-direction이 좋다.
    - bi-direction이 많으면 dependency가 높아진다.
<br><br>

### Algorithm

- Loop Invariant(루프 불변성)
    - 반복문이 실행되는 동안 절대 변하지 않는 성질.
    - ex) BST의 loop Invariant.
        - 1) 자식은 2개 이하이다.
        - 2) 왼쪽 자식은 나보다 작다.
        - 3) 오른쪽 자식은 나보다 크다.

- Introduction to Algorithm
    - 저자들의 이름을 줄여서 CRLS라 한다.

- java '검색어' oracle lesson
    - 이렇게 검색하면 공식 튜토리얼이 나온다.

- ADT Linked List 구현해보기.
    - 실제 list 구현체와 성능 비교.
<br><br>

### 코딩을 지탱하는 기술 ( ~ 84p)

#### 5장. 함수

- 함수의 탄생으로 인해 내포 구조를 다루는 방법, 재귀 호출 탄생
    - 내포 구조 : 어떤 물품이 그 물품 자신을 사용하여 만들어진 구조.
<br><br>

#### 6장. 에러 처리

- 프로그램도 실패를 한다.
- 실패 한 경우에 어떠한 알림도 없다면, 사용자는 실패를 알아차리기 힘들다.
- 빨리 알아차리지 못하면 큰 사고로 연결될 지도 모른다.
- 때문에 **실패를 알리는 구조**가 필요하다.

- 에러 처리를 어떻게 하면 좋을까?
    - 1) 반환 값으로 실패 플래그를 전달한다. 사용 시 반환 값을 체크하여 실패일 때 에러를 처리한다.
    - 2) 에러처리 코드를 등록해두고, 실패를 던지면 에러 처리 코드로 점프한다.

##### 1) 반환 값을 체크하여 실패일 때 에러를 처리한다.

- 1)의 문제점.
    - 실패를 놓친다.
        - 프로그래머가 함수를 사용한 후 반환값 체크를 잊는 경우.
        - 실패가 발생한 타이밍과 문제를 발견하는 타이밍이 다르다.
            - 반환값을 확인하는 로직이 바로 연속적으로 위치해 있지 않을 수도 있다.
            - 이를 계기로 다른 함수도 실패하는 사이드 이펙트가 발생할 수도 있다.            
            
    - 에러 처리 때문에 코드를 해석하기 어렵다.
        - 아래는 func 라는 함수가 실패할 수도 있다고 가정했을 때.

```java
    if(!func("A")){
        /*
        실패했을 때 처리
        */
    }
    else if(!func("B")){
        /*
        실패했을 때 처리
        */
    }
    else if(!func("C")){
        /*
        실패했을 때 처리
        */
    }
```


원래 하고 싶은 것은 *3개의 처리를 실행한다* 였지만 장황해졌다.

- 에러 코드를 한 곳에 정리해놓는다면, *실패했을 때의 처리* 와 *원래 하고 싶은 것을 기술한 코드*를 분리할 수 있다.
    - 아래가 1)의 베스트 방법.

```java
    if(!func("A")) goto ERROR;
    if(!func("B")) goto ERROR;
    if(!func("C")) goto ERROR;

    ERROR :
    /*
    실패했을 때의 처리
    */
```

- 1)의 경우 C언어를 포함한 다양한 언어에서 사용하고 있는 예외처리 방식이다.
<br><br>

##### 2) 실패를 던지면 에러 처리 코드로 점프한다.

- 2)의 경우를 살펴본다.
    - 사람이 반환값을 체크하지 않고, 언어 처리 단계에서 실패를 체크한다.

```
GO: procedure;
    on error go to ERROR;
    call func(1);
    call func(2);
    call func(3);
    return;
    ERROR : < 에러시 처리 >
end;
```
<br><br>

##### 자발적으로 실패할 것 같은 처리를 묶는 구문으로 발전

- try / catch
- why finally?
    - 예측하지 못한 종료가 발생했을 시에도 메모리 블록이나 파일 등의 리소스를 잘 닫을 수 있게 된다.
    - 짝이 되는 처리를 반드시 실행한다.
        - 예) lock을 했으면 unlock.
    - **출구는 하나다**
    - C++은 finally가 없는 대신, *소멸자*라는 방식을 택한다.

- 예외적 상황에 정답은 없으나, 저자는 틀리면 **바로** 예외를 던지는 것을 추천한다.
    - *Fail first*
        - 이상하면 처리를 정지하고 빨리 보고해야 한다. 는 설계 이념

> *구체적인 지식과 추상적인 지식* <br>
*언어 X로 Y를 하는 방법과 같은 구체적인 지식은 당신의 생산성을 바로 높일 수 있다. 그러나 언어가 바뀌면 무용지물이 된다. 세상은 계속 바뀌고 있다. 즉, 응용 범위가 제한된 구체적인 지식은 점점 그 가치를 잃어간다.* <br>
*반면, 추상적인 지식을 배워도 여러분이 가지고 있는 경험과 연관시키지 못하면 응용할 수 없다. 벚꽃이 가지고 싶다고 꽃이 피어있는 가지를 잘라와도 꽃이 죽어버리면 그만이다. 매년 꽃을 피게 하기 위해선 뿌리가 필요하다.* <br>
*뿌리가 없는 지식은 응용에 도달하지 못하고, 들어온 지식을 다시 토해낼 뿐이다. 상황에 맞게 지식을 활용할 수가 없는 것이다.*

















