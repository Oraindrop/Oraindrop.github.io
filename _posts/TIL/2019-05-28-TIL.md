---
layout: post
title:  "TIL(20190528)"
categories: TIL
author : choising
tags: til
---

# 20190528

## 자바 최적화 ( ~ p)

### Chapter 3. 하드웨어와 운영체제

- 성능을 진지하게 고민하는 자바 프로그래머는 가용 리소스를 최대한 활용할 수 있도록 자바 플랫폼의 근간 원리와 기술을 잘 알고 있어야 한다

#### 3.2 메모리

- 초기 트랜지스터는 클락율 향상에 집중했다
    - 시간이 갈수록 프로세서 코어의 데이터 수요를 메인 메모리가 맞추기 어려워졌다
    - 즉, `프로세서/메모리 간 성능 차이가 발생`
    - 클락율이 아무리 올라가도 데이터가 도착할 때 까지 CPU는 유휴

##### 3.2.1 메모리캐시

- 그래서 CPU 캐시 등장(`캐시 아키텍처`)
- 레지스터보다는 느리고 메모리보다는 빠른, CPU에 있는 메모리 영역
- 자주 액세스 하는 거는 CPU가 메인메모리를 재참조하지 않게 사본을 떠서 CPU 캐시에 보관하자는 아이디어
- 액세스 빈도가 높은 캐시일 수록 프로세서 코어와 더 가까이 위치 하는 식으로 여러 캐시 계층 존재
    - L1 : 가장 가까운 캐시
    - L2, L3..

- 일반적으로 각 실행 코어에 전용 프라이빗 캐시 L1, L2를 두고, 일부 또는 전체 코어가 공유하는 L3 캐시를 둠
- 최신 CPU는 더 많은 예산을 캐시에 투자
- 캐시 아키텍처로 프로세서 처리율은 개선되었지만, 다른 문제
    - 메모리에 있는 데이터를 어떻게 캐시로 가져오고, 캐시한 데이터를 어떻게 메모리에 다시 써야 할 지

- 캐시 일관성 프로토콜
    - MESI 프로토콜
        - 캐시 라인(보통 64바이트) 상태를 다음 네 가지로 정의
            - Modified(수정) : 데이터가 수정된 상태
            - Exclusive(배타) : 이 캐시에만 존재하고 메인 메모리 내용과 동일
            - Shared(공유) : 둘 이상의 캐시에 데이터가 들어 있고 메인 메모리 내용과 동일한 상태
            - Invalid(무효) : 다른 프로세스가 데이터를 수정하여 무효한 상태

- 처음에는 매번 캐시 연산 결과를 바로 메모리에 기록 했다
    - `write-through` (동시기록)
        - 메모리 대역폭을 많이 소모하는 등 효율이 낮아 현재는 거의 사용하지 않음
        - 쓸 때는 무조건 메모리에 접근할테니, write는 메모리 쓰는거랑 똑같음
- 이게 싫어서 나온 게
    - `write-back` (후기록)
        - write 시, cache 데이터만 변경함
        - Dirty 데이터가 됨 즉, 캐시와 메인메모리 데이터가 다를 수 있다
        - 때문에 수정 되었는지 확인하는 1cycle 이 필요함
    
- 최대 전송률을 결정하는 factor
    - 메모리 클락율
    - 메모리 버스 폭 (보통 64비트)
    - 인터페이스 개수 (요즘은 대부분 2개)

- DDR RAM 은 최대 전송률이 2배
    - DDR : Double Data Rate (이중 데이터 전송률)
        - 클록 신호 양단에서 통신

- 이 그래프를 못읽겠음

#### 3.3 최신 프로세서의 특성

##### 3.3.1 변환 색인 버퍼(TLB)

- 캐시에서 긴요하게 쓰이는 장치
- 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블 캐시 역할 수행
- 가상 주소 참조해 물리 주소에 액세스하는 빈번한 작업 속도 향상
- JVM에도 TLB라는 메모리 관련 기능이 있는데, 약자만 같고 다른 말이라는데 찾아봐도 안나옴 JVM TLB는

##### 3.3.2 분기 예측과 추측 실행

- 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지
- 조건문을 평가하기 까지 분기 이후 다음 명령을 알 수 없으므로, 프로세서는 여러 사이클 동안 멎게 된다
- 때문에 가장 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성
    - 미리 추측한 결과로 파이프라인을 채운다
    - 예측이 맞으면 아무 일 없던 것 처럼 CPU 다음 작업 진행
    - 틀리면 부분적으로 실행한 명령을 모두 폐기한 후 파이프라인을 비우는 대가를 치룸

##### 3.3.3 하드웨어 메모리 모델

- 멀티코어 시스템에서 두 개 이상의 코어가 같은 메모리 주소에 접근한다면 같은 값을 볼 수 있을까?
    - 이런 행위가 정확하게 동작하도록 메모리를 설계하는 것이 메모리 모델
    - 강한 메모리 모델 : 언제나 모든 프로세서가 같은 주소에서 같은 값을 볼 수 있다
    - 약한 메모리 모델 : 다른 프로세서의 write 연산을 현재 프로세서에 보여주거나, 현재 프로세서의 write 연산을 다른 프로세서에게 보여주기 위해 로컬 프로세서의 캐시를 무효화 하는 메모리 장벽이라는 특별한 명령어 집합을 가지고 있다고 한다 (lock, unlock 시 에 동작)
        - 출처 : <http://qwefgh90.github.io/java/JSR-133-(Java-Memory-Model)-FAQ(%EB%B2%88%EC%97%AD)/>
    - 멀티스레드 코드가 제대로 작동하게 하려면 lock, volatile을 정확히 알아야 한다 (추후 학습)

#### 3.4 운영체제

- OS의 주 임무는 여러 프로세스가 공유하는 리소스 액세스를 관장
- MMU(메모리 관리 유닛)을 통한 가상 주소 방식과 페이지 테이블은 메모리 액세스 제어의 핵심
    - 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게 한다

##### 3.4.1 스케줄러

- 프로레스 스케줄러 : CPU 액세스 통제
- 실행 큐 : 실행 대상이지만 CPU  차례를 기다려야 하는 스레드 혹은 프로세스의 대기장소

##### 3.4.3 컨텍스트 교환

- context switch : OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기중인 다른 스레드/태스크로 대체하는 프로세스

- 유저 스레드가 preemption 도중 커널 모드로 바뀔 때 컨텍스트 스위치가 일어나고 비용이 크다
    - 이를 최대한 만회하려고 리눅스는 vDSO 라는 장치를 제공한다
        - 굳이 kernel privileges 가 필요 없는 시스템 콜 때 커널 모드로 컨텍스트 스위치를 하지 않겠다는 개념
    
    - 자바에서도 이런 식으로 성능을 끌어 올릴 수 있다.

#### 3.5 단순 시스템 모델

- 기본 컴포넌트
    - 애플리케이션이 실행되는 
        - HW / OS
        - JVM / 컨테이너
    - 애플리케이션 코드
    - 애플레케이션이 호출하는 외부 시스템
    - 애플리케이션으로 유입되는 트래픽

#### 3.6 기본 감지 전략

- 애플리케이션이 잘 돌아간다는 건 CPU 사용량, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이요하고 있다는 뜻

- 성능 진단의 첫 단추는 범인 찾기
    - 어떤 리소스가 문제야?

##### 3.6.1 CPU 사용률

- vmstat 1
    - 1초마다 한 번 씩 찍어 다음 줄에 결과를 표시
    - proc : 실행가능한(r) 프로세스, 블로킹된(b) 프로세스 개수
    - memory : 스왑 메모리(swpd), 미사용 메모리(free), 버퍼로 사용되는 메모리(buff), 캐시로 사용한 메모리(cache)
    - swap : 디스크로 교체되어 들어간 메모리(스왑인, si), 디스크에서 교체되어 빠져나온 메모리(스왑아웃, so)
    - io : 블록인(bi), 블록아웃(bo)
    - system : 인터럽트(in) 초당 context switch 횟수(cs)
    - cpu : cpu 사용률(%), 유저시간(us), 커널시간(sy), 유휴시간(id), 대기시간(wa), 가상머신에 할애된 시간(st)

##### 3.6.2 가비지 수집

- JVM 프로세스가 유저 공간에서 CPU를 100% 가깝게 사용하고 있다면 GC를 의심

##### 3.6.3 입출력

- 파일 I/O 는 전체 시스템 성능에 암적인 존재
- 커널 바이패스 I/O 뭔지 모르겠음

##### 3.6.4 기계공감

- 성능을 조금이라도 쥐어짜내야 하는 상황에서 하드웨어를 폭넓게 이해하고 공감할 수 있는 능력이 무엇보다 중요하다는 생각

#### 3.7 가상화

- 이미 실행중인 OS 위에서 OS 사본을 하나의 프로세스로 실행시키는 모양
    - 가상화 OS에서 실행하는 프로그램은 베어 메탈(즉, 비 가상화 OS)에서 실행될 때와 동일하게 작동해야 한다
    - 하이퍼바이저는 모든 하드웨어 리소스 액세스를 조정해야한다
    - 가상화 오버헤드는 가급적 작아야 하며 실행시간의 상당부를 차지해선 안된다



    



    
