---
layout: post
title:  "TIL(20190604)"
categories: TIL
author : choising
tags: til
---

# 20190604

## 자바 최적화 ( ~ 176p)

### Chapter 6. 가비지 수집 기초

- 자바 가비지 수집의 요체는, 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것

- 가비지 수집 구현체의 기본 원칙 2가지
    - 알고리즘은 반드시 모든 가비지를 수집해야 한다
    - **살아 있는 객체는 절대로 수집해선 안된다**
        - 누가봐도 이게 엄청 중요

- 살아 있는 객체를 수집했다간 세그멘테이션 결함이 발생하거나, 프로그램 데이터가 조용히 더렵혀진다

#### 6.1 마크 앤 스위프

- 초보적인 마크 앤 스위프 알고리즘
    - `allocated list` (할당 리스트) : 메모리가 할당됐지만, 아직 회수되지 않은 객체
    1. allocated list 순회, mark bit를 지운다
    2. GC 루트부터 살아 있는 객체를 찾는다
    3. 찾은 객체(살아있는 객체) 마다 mark bit 를 set 한다
    4. allocated list를 순회하면서 mark bit가 세팅되지 않은 객체를 찾는다
        - 힙에서 메모리를 회수, free list 에 되돌린다
        - allocated list 에서 삭제한다

    - 살아있는 객체는 대부분 `DFS` 방식으로 찾는다
        - 이렇게 생성된 객체 그래프를 `라이브 객체 그래프` or `접근 가능한 객체의 전이 폐쇄` 라고도 한다


##### 6.1.1 가비지 수집 용어

- STW
    - GC Cycle 이 발생하여 가비지를 수집하는 동안에 모든 애플리케이션 스레드가 중단되는 현상
    - Stop The World

- 동시
    - GC 스레드와 어플리케이션 스레드가 `동시(병행)` 실행 될 수 있다는 개념

- 보수
    - 보수적인 스킴은 정확한 스킴의 정보가 없는 것
    - 리소스를 낭비하는 일이 잦고, 근본적으로 타입 체계를 무시하기에 비효율적

- 압착
    - 살아남은 객체들은 GC 사이클 마지막에 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다.
    - 메모리 단편화를 방지

- 방출
    - 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동(방출) 한다

#### 6.2 핫스팟 런타임 개요

- 신기한게 java 는 진짜 call by reference 는 없나봄
    - 전부 call by value 이고, 객체 레퍼런스의 경우 힙에 있는 주소 `값`

##### 6.2.1 객체를 런타임에 표현하는 방법

- `oop` : ordinary object pointer
    - 핫스팟은 런타임에 oop 라는 구조체로 자바 객체를 나타낸다
    - `instanceOop` 는 자바 클래스의 인스턴스를 나타냄
        - 인스턴스오오피의 메모리 레이아웃은 기계어 워드 2개로 구성된 헤더로 시작
            - `Mark 워드` : 인스턴스 관련 메타데이터 가리키는 포인터
            - `Klass 워드` : 클래스 메타데이터 가리키는 포인터

    - oop는 기계어 워드이기에 프로세서의 비트(32, 64) 를 따른다
    - 메모리의 낭비를 줄이고자 핫스팟은 `압축 oop`를 제공, 아래 oop 가 압축된다
        - 힙에 있는 모든 객체의 Klass 워드
        - 참조형 인스턴스 필드
        - 객체 배열의 각원소
        - 옵션 : -XX:+UseCompressedOops (자바 7 이상, 64비트 힙은 디폴트 옵션임)

- 핫스팟 객체 헤더
    - Mark 워드 (프로세서 비트(32, 64))
    - Klass 워드 (압축 됐을 듯)
    - 객체가 배열이면 length 워드 (항상 32비트)
    - 32비트 여백 (정렬 규칙 때문에 필요할 경우)

- JVM 환경에서 자바 레퍼런스는 instanceOop(or null) 를 제외한 어떤 것도 가리킬 수 없다
    - 자바 값은 기본 값 or instanceOop 레퍼런스
    - 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터
    - 자바 레퍼런스가 가리키는 주소에는 Mark 워드 + Klass 워드 가 들어있음

##### 6.2.2 GC 루트 및 아레나

- `GC 루트`
    - 메모리 풀 외부에서 내부를 가리키는 포인터
        - 메모리 풀 내부에서 내부의 다른 메모리 위치를 가리키는게 **내부 포인터** 인데 요놈은 정 반대인 **외부 포인터** 임

    - 종류
        - 스택 프레임
        - JNI
        - 레지스터 (호이스트된 변수)
        - JVM 코드 캐시에서 코드 루트
        - 전역 객체
        - load 된 클래스의 메타데이터

- `아레나`
    - 핫스팟 GC가 동작하는 메모리 영역

- 핫스팟은 자바 heap을 관리할 때 시스템 콜을 하지 않는다

#### 6.3 할당과 수명

- 가비지 수집의 주요 원인
    - `할당률`
        - 일정 기간 새로 생성된 객체가 사용한 메모리 양
    - `객체 수명`
        - 제대로 파악하기 어렵고, 더 핵심적 요인

##### 6.3.1 약한 세대별 가설

- 가설 1 : **거의 대부분 객체는 아주 짧은 시간만 살아있고, 나머지 객체는 기대 수명이 훨씬 길다**
    - 단명 객체를 쉽고 빠르게 수집할 수 있는 설계, 장수 객체와 단명 객체를 완전히 떼어놓는게 좋다
        - 객체마다 **세대 카운트** (나이) 를 센다
        - 큰 객체 외 에덴 공간에 생성한다
            - 여기서 살아남은 객체는 다른 곳으로 옮긴다
        - 장수 객체는 별도의 메모리 영역(올드 or 테뉴어드)에 보관

- 가설 2 : **늙은 객체가 젊은 객체를 참조할 일은 거의 없다**
    - `카드 테이블` 이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록
        - 카드 테이블은 JVM이 관리하는 바이트 배열, 각 원소는 올드 세대 공간의 512 바이트 영역을 가리킨다
            - 늙은 객체 o에 있는 참조형 필드값이 바뀌면 o에 해당하는 instanceOop가 들어 있는 카드를 찾아 해당 엔트리를 더티 마킹
            - 핫스팟은 레퍼런스 필드를 업데이트 할 때 마다 write barrier를 이용한다.
                - 아직 이해를 못했고 일단 적는다

#### 6.4 핫스팟의 가비지 수집

- 자바는 OS를 이용해 동적으로 메모리를 관리하지 **않는다**
    - 프로세스 시작 > JVM 메모리 할당 > 유저공간에서 연속된 단일 메모리 풀을 사용

##### 6.4.1 스레드 로컬 할당

- 에덴을 여러 버퍼로 나누어 각 스레드가 새 객체를 할당하는 구역으로 활용
    - 이 구역을 `Thread-Local Allocation Buffer` TLAB 라고 한다
        - TLAB 크기는 동적 조정, 한 스레드가 메모리 오지게 쓰면 거대한 TLAB을 할당

##### 6.4.2 반구형 수집
    - (보통 크기가 같은) 두 공간을 사용하자
        - 절반의 공간은 항상 완전히 비운다
        - 수집된 반구는 비워서 재사용한다



